---
title: Route Protection | Next.js
description: Learn how to protect the routes in your application 
---

# Route Protection

Clerk offers you, the developer, many options to protect the routes in your application, as well as easy ways to integrate role or permissions-based checks. The opt-in nature of Clerk gives you flexibility in how you build your application.

## Clerk's Core Concepts for Route Protection

### Opt-In Protection For Routes

`clerkMiddleware()` provides opt-in protection for your routes. By default, no routes will be protected. You will indicate what routes to protect through the Middleware, layouts, or even per route/page. 

### Integration with Organizations and Roles

`clerkMiddleware()` provites a new `auth().protect()` method that can be used when creating rules to protect pages. This will integrate with Organization role and permissions, allowing you to protect routes based on the permissions or roles a user has.

### Protect Routes via Middleware, Layout, Pages, or a Mixture of All Three

With the opt-in approach of `clerkMiddleware()`, you are free to protect your routes and pages in the most convenient way to you.

## Protect routes with Middleware only

Does your application have limited or straight forward route protection needs? Configuring your protection in Middleware and only Middleware could be the play. Perhap your application is only available to signed in users, or most of your app is under the `/dashboard` route and only available for signed in users. In this case protecting from Middleware is a central location that enables this protection.

The following example would require users visiting the `/dashboard` route to be signed in, in order to access the route. If they are not authenticated, [`auth().protect()`](/docs/references/nextjs/auth#authorization-with-protect) would redirect them to the sign-in route.
{/* TODO: update link for protect()... we are currently figuring out if we need to create a dedicated page for it or simply add more information to its section on the auth() docs page. */}

```tsx filename="app/src/middleware.ts"
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware(
  (auth, req) => {
    if (  req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

## Protect routes with Middleware and Layout or Page

Applications with more complex protection needs may be well suited to use a mix of Middleware and Layout or Page-based protection. Your application may have a `/dashboard` section, but within that, it might have routes or specific pages that are limited to users with a specific role or permission. In a situation such as this, you might enforce that only signed in users can access `/dashboard` in your Middleware, and then add specific role-based checks to the `layout.tsx` for a route like `/dashboard/manage-users`.

### Protect routes with Middleware and Layout example

The following example uses `clerkMiddleware()` to protect all `/dashboard` routes. If a user is not authenticated, [`auth().protect()`](/docs/references/nextjs/auth#authorization-with-protect) would redirect them to the sign-in route.

```tsx filename="app/src/middleware.ts"
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware(
  (auth, req) => {
    if (  req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

Paired with the example above, which checks if a user visiting any `/dashboard` route is authenticated, the following example would require users visiting the `/dashboard/manage-users` route to be authenticated *and* to have the `org:admin` role. If they are not authenticated or do not have the `org:admin` role, [`auth().protect()`](/docs/references/nextjs/auth#authorization-with-protect) would redirect them to the sign-in route.

```tsx filename="app/src/dashboard/manage-users/layout.tsx" 
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function HookLayout({ children }: { children: React.ReactNode }) {
  if (!auth().has({ role: "org:admin" })) {
    redirect("/")
  }
  return <>{children}</>
}
```

### Protect routes with Middleware and Page example

The following example uses `clerkMiddleware()` to protect all `/dashboard` routes. If a user is not authenticated, [`auth().protect()`](/docs/references/nextjs/auth#authorization-with-protect) would redirect them to the sign-in route.

```tsx filename="app/src/middleware.ts"
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware(
  (auth, req) => {
    if (  req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

Paired with the example above, which checks if a user visiting any `/dashboard` route is authenticated, the following example would require users visiting the `/dashboard/manage-users` route to be authenticated *and* to have the `org:admin` role. [`auth().has()`](/docs/references/nextjs/auth#authorization-with-protect) would detect whether or not the user has the `org:admin` role.

```tsx filename="app/src/dashboard/manage-users/page.tsx" 
import { auth } from '@clerk/nextjs/server'

export default function Page() {

if (!auth().has({ role: "org:admin" })) {
    return <p>You do not have permission to view this page.</p>
  }

  return (
    <>
      <h1>Manage Users</h1>
      <p>Manage your users, invite new users or ban users</p>
    </>
  );
}
```

## Protect routes with Layout or Page only (no Middleware)

Clerk's `clerkMiddleware()` is purely opt-in, meaning if you don't add any specific protection to the Middleware, all routes are public. This allows you to then enforce protections via *only* layouts, or even pages, and keep your protection logic scoped to that specific area that it governs in your application.

The following examples show how to protect the `/dashboard/manage-users` route with only a Layout *or* only a Page.

### Protect routes with Layout example

```tsx filename="app/src/dashboard/manage-users/layout.tsx" 
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function HookLayout({ children }: { children: React.ReactNode }) {
  if (!auth().has({ role: "org:admin" })) {
    redirect("/")
  }
  return <>{children}</>
}
```

### Protect routes with Page example

```tsx filename="app/src/dashboard/manage-users/page.tsx" 
import { auth } from '@clerk/nextjs/server'

export default function Page() {

if (!auth().has({ role: "org:admin" })) {
    return <p>You do not have permission to view this page.</p>
  }

  return (
    <>
      <h1>Manage Users</h1>
      <p>Manage your users, invite new users or ban users</p>
    </>
  );
}
```